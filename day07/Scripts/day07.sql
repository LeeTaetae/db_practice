SELECT DISTINCT PRODUCT_NAME FROM TBL_ORDER TBO JOIN TBL_PRODUCT TBP ON TBO.PRODUCT_ID = TBP.ID;


SELECT SYSDATE FROM DUAL;

-- 논리 연산자
-- 1. BETWEEN A AND B : A부터 B까지
SELECT * FROM(SELECT DISTINCT TBO.*, TBP.PRODUCT_BRAND, TBP.PRODUCT_PRICE FROM TBL_ORDER TBO JOIN TBL_PRODUCT TBP ON TBO.PRODUCT_ID = TBP.ID) WHERE PRODUCT_PRICE BETWEEN 100000 AND 300000;
SELECT DISTINCT PRODUCT_NAME FROM TBL_ORDER TBO JOIN TBL_PRODUCT TBP ON TBO.PRODUCT_ID = TBP.ID AND TBP.PRODUCT_NAME = '청바지';

--같지않다. !=, <>
SELECT * FROM(SELECT DISTINCT TBO.*, TBP.PRODUCT_BRAND, TBP.PRODUCT_PRICE FROM TBL_ORDER TBO JOIN TBL_PRODUCT TBP ON TBO.PRODUCT_ID = TBP.ID) WHERE PRODUCT_PRICE <> 119000;

--IS NULL : NULL인 데이터
SELECT * FROM(SELECT DISTINCT TBO.*, TBP.PRODUCT_BRAND, TBP.PRODUCT_PRICE FROM TBL_ORDER TBO JOIN TBL_PRODUCT TBP ON TBO.PRODUCT_ID = TBP.ID) WHERE ORDER_END_DATE IS NULL;
-- IS NOT NULL : NULL이 아닌 데이터
SELECT * FROM(SELECT DISTINCT TBO.*, TBP.PRODUCT_BRAND, TBP.PRODUCT_PRICE FROM TBL_ORDER TBO JOIN TBL_PRODUCT TBP ON TBO.PRODUCT_ID = TBP.ID) WHERE ORDER_END_DATE IS NOT NULL;

-- 문자열 함수
-- CONCAT(값1, 값2)
SELECT CONCAT('HELLO', ' WORLD') FROM DUAL;
SELECT 'HELLO' || ' WORLD' AS "인사" FROM DUAL;

-- LENGTH() : 길이
SELECT LENGTH(CONCAT('HELLO', ' WORLD')) FROM DUAL;

-- SUBSTR() : 문자열 추출 - 오라클
-- SUBSTRING() : 문자열 추출 - MYSQL
SELECT SUBSTR('오늘 점심 뭐 먹지?', 4, 2) FROM DUAL;

-- 중복 연산자
--1) DISTINCT : 조회 결과의 중복을 제거함
--2) UNION : 중복을 제거하고, 두 컬럼 데이터 조회를 합친다.
SELECT SQLD_PRODUCT_NAME FROM SQLD_PRODUCT
UNION
SELECT SQLD_ORDER_NAME FROM SQLD_ORDER;

--3) UNION ALL : 중복을 제거하지 않고, 두 컬럼 데이터 조회를 합친다.
SELECT SQLD_PRODUCT_NAME FROM SQLD_PRODUCT
UNION ALL
SELECT SQLD_ORDER_NAME FROM SQLD_ORDER;

--4) MINUS
SELECT SQLD_PRODUCT_NAME FROM SQLD_PRODUCT
MINUS
SELECT SQLD_ORDER_NAME FROM SQLD_ORDER;

--5) INTERSECT : 교집합
SELECT SQLD_PRODUCT_NAME FROM SQLD_PRODUCT
INTERSECT
SELECT SQLD_ORDER_NAME FROM SQLD_ORDER;

-- 공집합
--1) 0
--2) NULL
--3) 공집합
--4) 오류

-- NULL 관련 연산자
--1) IS NULL : NULL 이면 TRUE
--2) IS NOT NULL : NULL이 아니면 TRUE

--===================================================================
-- 함수
--===================================================================
-- 문자열 함수
-- UPEER() : 대문자로 변경
SELECT UPPER('hello') FROM DUAL;

-- LOWER() : 소문자로 변경
SELECT LOWER('DATING') FROM DUAL; 

-- TRIM() : 공백제거
SELECT TRIM('점 심 맛 있 게 머 겄 어?') FROM DUAL;

--REPLACE(값, 찾을 문자, 바꿀 문자) : 특정 문자를 치환
SELECT REPLACE ('  점 심 맛 있 게 머 겄 어?' , ' ' ,'' ) FROM DUAL;

-- INSTR() : 특정 문자열의 위치 반환
SELECT INSTR('강사님 질문해도 될까요?' , '질문') FROM DUAL;

-- 날짜 함수
-- SYSDATE : 현재 날짜, 시, 분, 초
SELECT SYSDATE FROM DUAL;

--CURRENT_DATE : 날짜만 가지고 오는 것
SELECT CURRENT_DATE FROM DUAL;

-- 현재 날짜를 기준으로 월을 추가
SELECT ADD_MONTHS(SYSDATE, 2) FROM DUAL; 

--MONTHS_BETWEEN()
SELECT MONTHS_BETWEEN('2024-07-12', SYSDATE) FROM DUAL;

-- 일 차이
SELECT (SYSDATE - TO_DATE('2025-09-15 11:15:00', 'YYYY-MM-DD HH24:MI:SS')) FROM DUAL;

-- 시 차이
SELECT (SYSDATE - TO_DATE('2025-09-18 11:15:00', 'YYYY-MM-DD HH24:MI:SS')) * 24 FROM DUAL;

-- 분 차이
SELECT (SYSDATE - TO_DATE('2025-09-18 11:15:00', 'YYYY-MM-DD HH24:MI:SS')) * 24 * 60 FROM DUAL;

-- 초 차이
SELECT (SYSDATE - TO_DATE('2025-09-18 11:15:00', 'YYYY-MM-DD HH24:MI:SS')) * 24 * 60 * 60 FROM DUAL;

-- NEXT_DAT()
-- 특정 날짜 이후의 지정된 요일을 반환
SELECT NEXT_DAY(SYSDATE, '월요일') FROM DUAL; 

-- TRUNC() : 날짜의 시각을 제거하고 날짜만 반환
SELECT TRUNC(SYSDATE) FROM DUAL;

--TRUNCATE 
SELECT * FROM TBL_INCOME;

SELECT
	TO_DATE('2025-09-18 11:15:00', 'YYYY-MM-DD HH24:MI:SS'),	
	TO_CHAR(
		TO_DATE('2025-09-18 11:15:00' , 'YYYY-MM-DD HH24:MI:SS'),
		'HH') AS "시간",
		TO_CHAR(
		TO_DATE('2025-09-18 11:15:00' , 'YYYY-MM-DD HH24:MI:SS'),
		'MI') AS "분",
		TO_CHAR(
		TO_DATE('2025-09-18 11:15:00' , 'YYYY-MM-DD HH24:MI:SS'),
		'YYYY') AS "년도"
FROM DUAL;

-- ABS() : 절댓값을 반환
SELECT ABS(-100) FROM DUAL;

--CEIL() : 주어진 숫자보다 크거나 같은 최소의 정수를 반환
SELECT CEIL (3.14) FROM DUAL;

-- FLOOR() : 내림
SELECT FLOOR(3.9) FROM DUAL;
 	
-- MOD()
-- 나머지
SELECT MOD(5, 2) FROM DUAL;

-- ROUND() : 반올림
-- POWER() : 거듭제곱
SELECT POWER(2, 8) FROM DUAL;

--변환 함수
SELECT  TO_NUMBER('1234.5') + 10 FROM DUAL;
SELECT TO_TIMESTAMP('2025-02-25 16:40:00', 'YYYY-MM-DD HH24:MI:SS') FROM DUAL; 
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD') FROM DUAL;

-- SELECT TO_DATE()
SELECT CAST(10 AS VARCHAR2(255)) FROM DUAL;
SELECT CAST('10.5' AS NUMBER) FROM DUAL;
SELECT '10.5' + 100 FROM DUAL;
SELECT CAST('2025-02-17' AS DATE) FROM DUAL;

-- ***NULL 함수
--NVL() : 첫 번쨰 값이 NULL이면 두번쨰 값을 반환함
SELECT NVL(NULL, '대체 값') FROM DUAL;

-- 삼항
-- NVL2(값1, 값2, 값3) : 
SELECT NVL2(10, 'TRUE', 'FALSE') FROM DUAL;

-- COALESCE(값1, 값2, 값3, 값4...) : 값 중 NULL이 아닌 첫 번째 값을 반환
SELECT COALESCE(NULL, 0, NULL, 15) FROM DUAL;

-- NULLIF() 
-- 두 값이 같으면 NULL, 아니면 첫 번쨰 값
SELECT NULLIF(10, NULL) FROM DUAL;

-- 조건식
-- IS NULL
-- IS NOT NUL

-- CASE문
SELECT 
	CASE BUYER_GENDER
		WHEN '남' THEN '남성 고객'
		WHEN '여' THEN '여성 고객'
		ELSE '중성 고객'
	END AS "고객 성별"
FROM TBL_BUYER;

--START WITH
--CONNECT BY PRIOR 부모와 자식 관계
DROP SEQUENCE  SEQ_PRODUCT;
CREATE SEQUENCE SEQ_PRODUCT;
CREATE TABLE TBL_PRODUCT(
	ID NUMBER CONSTRAINT PK_PRODUCT PRIMARY KEY,
	PRODUCT_NAME VARCHAR2(255),
	PRODUCT_PRICE NUMBER
);

INSERT INTO TBL_PRODUCT VALUES(SEQ_PRODUCT.NEXTVAL, '컴퓨터', 220000);
INSERT INTO TBL_PRODUCT VALUES(SEQ_PRODUCT.NEXTVAL, '모니터', 40000);
INSERT INTO TBL_PRODUCT VALUES(SEQ_PRODUCT.NEXTVAL, '모니터', 30000);
INSERT INTO TBL_PRODUCT VALUES(SEQ_PRODUCT.NEXTVAL, '스피커', 55000);
INSERT INTO TBL_PRODUCT VALUES(SEQ_PRODUCT.NEXTVAL, '스피커', 12000);
INSERT INTO TBL_PRODUCT VALUES(SEQ_PRODUCT.NEXTVAL, '스피커', 30000);
INSERT INTO TBL_PRODUCT VALUES(SEQ_PRODUCT.NEXTVAL, '컴퓨터', 300000);
INSERT INTO TBL_PRODUCT VALUES(SEQ_PRODUCT.NEXTVAL, '마우스', 30000);
INSERT INTO TBL_PRODUCT VALUES(SEQ_PRODUCT.NEXTVAL, '마우스', 35000);
INSERT INTO TBL_PRODUCT VALUES(SEQ_PRODUCT.NEXTVAL, '마우스', 10000);

--SELECT PRODUCT_NAME, PRODUCT_PRICE, DENSE_RANK() OVER(PARTITION BY PRODUCT_NAME ORDER BY PRODUCT_PRICE DESC), 
--	DENSE_RANK() IVER(PARTITION BY PRODUCT_NAME ORDER BY PRODUCT_PRICE DESC),
--	ROW_NUMBER() OVER(ORDER BY PRODUCT_PRICE DESC) AS "ROWS_NUMBER",
--	SUM(PRODUCT_PRICE) OVER(PARTITION BY PRODUCT_NAME) AS "SUM" FROM TBL_PRODUCT;

SELECT 
	PRODUCT_PRICE,
	LEAD(PRODUCT_PRICE, 1) OVER(ORDER BY PRODUCT_PRICE) AS "LEAD",
	LAG(PRODUCT_PRICE, 2) OVER(ORDER BY PRODUCT_PRICE) AS "LAG" ,
	FIRST_VALUE(PRODUCT_PRICE) OVER(ORDER BY PRODUCT_PRICE) AS "FIRST_VALUE",
	LAST_VALUE(PRODUCT_PRICE) OVER(
		ORDER BY PRODUCT_PRICE
		ROWS BETWEEN 1 PRECEDING AND 5 FOLLOWING 
	) AS "LAST_VALUE" ,
	NTH_VALUE(PRODUCT_PRICE, 2) OVER(ORDER BY PRODUCT_PRICE) AS "NTH_VALUE",
	
FROM TBL_PRODUCT;

-- 집계쿼리
SELECT 
	PRODUCT_NAME, PRODUCT_PRICE,
	SUM(PRODUCT_PRICE),
	COUNT(PRODUCT_NAME)
FROM TBL_PRODUCT
GROUP BY ROLLUP(PRODUCT_NAME, PRODUCT_PRICE);

--더미 테이블 생성
CREATE SEQUENCE SEQ_SQLD_PRODUCT;
CREATE TABLE SQLD_PRODUCT(
	ID NUMBER CONSTRAINT PK_SQL_PRODUCT PRIMARY KEY,
	SQLD_PRODUCT_NAME VARCHAR2(255),
	SQLD_PRODUCT_PRICE NUMBER
);

INSERT INTO SQLD_PRODUCT
VALUES(SEQ_SQLD_PRODUCT.NEXTVAL, '지우개', 20000);

INSERT INTO SQLD_PRODUCT
VALUES(SEQ_SQLD_PRODUCT.NEXTVAL, '지우개', 20000);

INSERT INTO SQLD_PRODUCT
VALUES(SEQ_SQLD_PRODUCT.NEXTVAL, '키보드', 20000);

INSERT INTO SQLD_PRODUCT
VALUES(SEQ_SQLD_PRODUCT.NEXTVAL, '모니터', 30000);

CREATE SEQUENCE SEQ_SQLD_ORDER;
CREATE TABLE SQLD_ORDER(
	ID NUMBER CONSTRAINT PK_SQLD_ORDER PRIMARY KEY,
	SQLD_ORDER_NAME VARCHAR2(255),
	SQLD_PRODUCT_ID NUMBER,
	CONSTRAINT FK_SQLD_ORDER_SQLD_PRODUCT FOREIGN KEY(SQLD_PRODUCT_ID)
	REFERENCES SQLD_PRODUCT(ID)
);

INSERT INTO SQLD_ORDER 
VALUES(SEQ_SQLD_ORDER.NEXTVAL, '문 앞 배송', 1);


INSERT INTO SQLD_ORDER 
VALUES(SEQ_SQLD_ORDER.NEXTVAL, '직접 수령', 2);


INSERT INTO SQLD_ORDER 
VALUES(SEQ_SQLD_ORDER.NEXTVAL, '문 앞 배송', 2);








